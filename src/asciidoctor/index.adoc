= ActiveSlick
:linkcss:
:toc2:
:icons: font
:source-highlighter: pygments
:pygments-style: monokai
:pygments-linenums-mode: inline


ActiveSlick is a library that offers CRUD operations for Slick 3.0 projects. The main goal is to provide some basic operations to manage the lifecycle of persisted objects (new/persisted/deleted/stale) and enable the implementation of the Active Record Pattern on Slick mapped case classes.

== Main features
- Basic CRUD and auxiliary methods - add/update/save, delete, findById, count and fetchAll (backed by Reactive Streams).
- Generic Id type. 
- Optimistic locking my means of incremental version.
- **ActiveRecord** trait to enable the Active Record Pattern on mapped case classes via class extensions (pimp-my-library style)

== Project artifact

The artifacts are published to Sonatype Repository. Simply add the following to your build.sbt.

As of version 0.3.0 we don't support Slick 2.0 anymore. The differences between Slick 2.0 and Slick 3.0 are so huge that it makes impossible to support two versions. 

[source,scala]
----  
libraryDependencies += "io.strongtyped" %% "active-slick" % "0.3.0"
----
Source code for version 0.3.0 can be found at:
https://github.com/strongtyped/active-slick/tree/v0.3.0


The version supporting Slick 2.0 is still available on Sonatype Repo. However, this documentation only covers the current version (i.e.: 0.3.0).
[source,scala]
----  
libraryDependencies += "io.strongtyped" %% "active-slick" % "0.2.2"
----

Source code for version 0.2.2 can be found at:
https://github.com/strongtyped/active-slick/tree/v0.2.2


== Motivation

Slick is able to map result sets to case classes or Tuples because of its isomorphism. This is done thanks to built-in Scala features. However, there is no direct link between case class fields and database columns. Everything is done based on isomorphic projections.

As a consequence, managing of Entities IDs must be done by hand, over and over again. One needs to save a model, ask Slick to return the generated ID and add it explicitly to the case class.

The following code fragment demonstrates how this is typically done in a Slick application.  


[source,scala,linenums]
----  
include::../../modules/samples/src/main/scala/io/strongtyped/active/slick/docexamples/MappingWithoutActiveSlick.scala[tags=adoc]
----

Both **Coffee** and **CoffeeTable** have an **Id** representing the primary key. **Coffee** has a field of type **Option[Int]** (#1) and **CoffeeTable** has a method returning a **Rep[Int]** (#2). However, in order to inserta new Coffee we need some boilerplate to get back the generated ID (#3).

If we manage to connect both **ID** we can provide some generic functionality to manage Entities. Inserting a new Entity is only one of the possible use cases. With a well known ID, we can distinguish if an Entity has been already persisted or not, we can easilly implement byId methods (deleteById, findById) and we can add extensions methods like: save, udpate, delete


== History
The first intention of this project was to implement Slick DAOs or Repositories using only Scala features and the Scala compiler (no code generation).

In the time of Slick 2.0, this library required the usage of the Cake Pattern to wire together all the parts wihtout pre-defining a driver. 

Since Slick 3.0 imposes a huge refactoring, we decided to turn ActiveSlick inside out and eliminate the need of the Cake Pattern.


== Mapping using ActiveSlick

The following code fragment illustrates how we can use ActiveSlick **EntityActions** to bind the model Id field and the table id column.  

[source,scala,linenums]
----  
include::../../modules/samples/src/main/scala/io/strongtyped/active/slick/docexamples/MappingWithActiveSlick.scala[tags=adoc]
----

The mapping is basically the same. Except that Coffee implements **Identifiable** However, we define it inside **CoffeeRepo** which implements **EntityActions**.

We have now a well known column for our primary key. The next step is to define the method to extract the id from our model and to add a generated id back into the model. 

== Transactions
As of version 0.3.0 and the introduction of DBIO in Slick 3.0, all methods return DBIO (not Futures). In Slick 3.0 the DB sessions and the transactional sessions are not passed as implicit parameters therefore is the user that have to manage the sessions and transactions.

If ActiveSlick were returning Futures instead, then the transactions will have to be managed internally by ActiveSlick which is of course not desirable.



